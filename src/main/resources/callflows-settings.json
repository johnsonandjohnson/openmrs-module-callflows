{
  "configs": [

  ],
  "renderers": [
    {
      "name": "vxml",
      "mimeType": "application/voicexml+xml",
      "template": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<vxml version=\"2.1\">\n  \n  ## Note: All over-rides below must be over-ridden in your flow, preferably your entry flow\n\t\n  ## Over-ride for a different timeout between user prompts\n  #if (! $timeout) #set($timeout = 5) #end\n  \n  ## Mandatorily over-ride this with the current caller's locale based on how your application stores it\n\t#if (! $locale) #set($locale = \"en\") #end \n  \n  ## over-ride this if you want to use a different skip character\n  #if (! $skipChars) #set($skipChars = \"*\") #end\n  \n  ## Mandatorily over-ride this with the new flow name that you want to skip to if the skipChars is pressed\n  #if ($internal.callDirection == \"OUTGOING\" && $skipFlow && $skipFlow != \"\")  \n\t<link event=\"SkipEvent\">\n\t\t<grammar xml:lang=\"en-us\" version=\"1.0\" root=\"skipRule\" mode=\"dtmf\">\n\t\t\t<rule id=\"skipRule\" scope=\"public\">\n\t\t\t\t<item>${skipChars}</item>\n\t\t\t</rule>\n\t\t</grammar>\n\t</link>\n\n\t<catch event=\"SkipEvent\">\n\t\t<submit next=\"${internal.nextURL}?jumpTo=${skipFlow}\" />\n\t</catch>\n  #end\n    \n<%\n  \n  // Toggle this, if you want to observe renderer output in your browser console\n  var DEBUG = false;\n\n\tvar sayAsTTS = function(txt, element) {\n\t\tvar out = '',\n\t\t\t\tbargeIn = element.bargeIn ? true : false;\n\n\t\tif (txt.match(/^\\s*$/)) {\n\t\t\treturn out;\n\t\t}\n    if (DEBUG) {\n      console.log('[TTS]: ' + txt);\n    }\n\t\tout += '\\n\\t\\t<prompt bargein=\"';\n\t\tif (element.type === 'field') {\n      out += bargeIn;\n\t\t  out += '\" timeout=\"';\n      out += '${timeout}';\n      out += 's';\n\t\t} else {\n      out += true;\n    \tout += '\" bargeintype=\"hotword';\n    }\n\t\tout += '\">';\n\t\tout += txt;\n\t\tout += '</prompt>';\n\t\treturn out;\n\t}\n\n\tvar sayAsAudio = function(txt, mappings, element) {\n\t\tvar out = '',\n        msgPlayed = '',\n\t\t\t\tbargeIn = element.bargeIn ? true : false;\n\t\tif (txt.match(/^\\s*$/)) {\n\t\t\treturn out;\n\t\t}\n\t\tout += '\\n\\t\\t<prompt bargein=\"';\n\t\tout += bargeIn;\n\t\tif (element.type === 'field') {\n\t\t  out += '\" timeout=\"';\n\t\t  out += '${timeout}';\n\t\t  out += 's';\n\t\t}\n\t\tout += '\">';\n\t\tif (txt.indexOf('$') === -1) {\n\t\t\t// Not dynamic\n\t\t\tout += '\\n\\t\\t\\t<audio src=\"${internal.baseURL}/cmsliteapi/stream/$locale/' + mappings[0].mapping + '\" />';\n\t\t} else {\n\t\t\tout += '\\n\\t\\t\\t<audio src=\"${internal.baseURL}/cmsliteapi/stream/$locale/' + txt + '\" />';\n\t\t}\n\t\tout += '\\n\\t\\t</prompt>';\n\t\treturn out;\n\t}\n\n\tvar speak = function(element, txt, audio) {\n\t\tvar out = '',\n\t\t\tbq = \"`\",\n\t\t\t\tphrase = '',\n\t\t\t\taudioStream = false,\n\t\t\t\tnumberText = '<prosody rate=\"-20%\"><say-as interpret-as=\"vxml:digits\">$1</say-as></prosody>',\n\t\t\t\tdtText = '<prosody rate=\"-20%\"><say-as interpret-as=\"vxml:date\">$DateTimeFormat.forPattern(\"yyyyMMdd\").print($1)</say-as></prosody>',\n\t\t\t\tnumberServerText = \"#set($chars = $1.toString().toCharArray())\\n#foreach ($char in $chars)\\n\\t `num_00${char}` \\n#end\",\n\t\t\t\tpercentageText = \"#set($noValue = $1)\\n #if($noValue < 10) `num_00${noValue}` #elseif ($noValue < 100) `num_0${noValue}` #else `num_${noValue}` #end\",\n\t\t\t\tdtServerText = '',\n\t\t\t\ti, j;\n\t\t\t\t\n\t\tif (! audio) {\n\t\t\taudio = {};\n\t\t}\n\t\tif (DEBUG) {\n      console.log('speak: ' + txt);\n    }\n\n\t\t// Place custom delimiters here\n\t\ttxt = txt.replace(/__\\s*(.*?)\\s*__/g, numberText);\t\n\t\ttxt = txt.replace(/_\\[\\s*(.*?)\\s*\\]_/g, numberServerText);\n\t\ttxt = txt.replace(/_%\\s*(.*?)\\s*%_/g, percentageText);\n\t\ttxt = txt.replace(/%%\\s*(.*?)\\s*%%/g, dtText);\t\n\t\ttxt = txt.replace(/%\\[\\s*(.*?)\\s*\\]%/g, dtServerText);\t\n    \n\t\tif (DEBUG) {\n      console.log('speak (transformed): ' + txt);\n    }\n\n\t\tfor (i = 0; i < txt.length; i+=1) {\n\t\t\tif (txt[i] !== '`') {\n\t\t\t\tphrase += txt[i];\n\t\t\t} else {\n\t\t\t\tif (! audioStream) {\n\t\t\t\t\t// backquote opened, start a audio stream\n\t\t\t\t\taudioStream = true;\n\t\t\t\t\tif (phrase) {\n\t\t\t\t\t\tout += sayAsTTS(phrase, element);\n\t\t\t\t\t}\n\t\t\t\t\t// reset phrase\n\t\t\t\t\tphrase = '';\n\t\t\t\t} else {\n\t\t\t\t\t// closed audio stream\n          if (DEBUG) {\n\t\t\t\t\t\tconsole.log('[AUDIO]: ' + phrase);\n          }  \n\t\t\t\t\tout += (audio[phrase] || phrase.indexOf('$') >= 0) ? sayAsAudio(phrase, audio[phrase], element) : sayAsTTS(phrase, element);\n\t\t\t\t\tphrase = '';\n\t\t\t\t\taudioStream = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout += sayAsTTS(phrase, element);\n\t\treturn out;\n\t};\n\n\tvar fields = [];\n\t_.each(node.blocks, function(block) {\n    var dtmf, voice, rule;\n\t\tif (block.type === 'form') {\n\t\t\tprint('\\n<form>');\n\t\t\t_.each(block.elements, function(element) {\n\t\t\t\tif (element.type === 'txt') {\n\t\t\t\t\tprint('\\n\\t<block>');\n\t\t\t\t\tprint(speak(element, element.txt, flow.raw.audio));\n\t\t\t\t\tif (node.continueNode) {\n\t\t\t\t\t\tprint('\\n\\t</block>');\n\t\t\t\t\t\tprint('\\n\\t<field name=\"finishedHearing\">');\n            print('<property name=\"timeout\" value=\"0.1s\" />');\n            print('\\n\\t\\t<grammar xml:lang=\"en-us\" version=\"1.0\" root=\"finishedRule\" mode=\"dtmf\"><rule id=\"finishedRule\" scope=\"public\"><item>@</item></rule></grammar>');\n            print('\\n\\t\\t<nomatch />');\n\t\t\t\t\t\tprint('\\n\\t\\t<noinput count=\"1\"><goto nextitem=\"submit\" /></noinput>');\n\t\t\t\t\t\tprint('\\n\\t</field>');\n\t\t\t\t\t\tprint('\\n\\t<block name=\"submit\">');\n\t\t\t\t\t\tprint('\\n\\t\\t<goto next=\"${internal.nextURL}?_dt=$DateTime.now().getMillis()\" />');\n\t\t\t\t\t}\n\t\t\t\t\tprint('\\n\\t</block>');\n\t\t\t\t} else if (element.type === 'field') {\n\t\t\t\t\tprint('\\n\\t<field ');\n\t\t\t\t\tif (element.name) {\n\t\t\t\t\t\tfields.push(element.name);\n\t\t\t\t\t\tprint('name=\"' + element.name + '\" ');\n\t\t\t\t\t}\n          // use a type to over-ride only if grammars are not present\n          if ((element.dtmf && !element.dtmfGrammar) || (element.voice && !element.voiceGrammar)) {\n            if (element.fieldType) {\n              print('type=\"' + element.fieldType);\n            }\n            if (element.fieldMeta) {\n              if (element.fieldMeta.indexOf('..') === -1) {\n                print('?length=' + element.fieldMeta);\n              } else {\n                var range = element.fieldMeta.split('..');\n                if (range.length === 2 && element.fieldMeta.startsWith('..')) {\n                  print('?maxlength=' + range[1]);\n                } else if (range.length === 2 && element.fieldMeta.endsWith('..')) {\n                  print('?minlength=' + range[0]);\n                } else if (range.length === 2) {\n                  print('?minlength=' + range[0] + ';maxlength=' + range[1]);\n                }\n              }\n            }\n            if (element.fieldType) {\n              print('\"');\n            }\n          }  \n\t\t\t\t\tprint('>');\n\t\t\t\t\tif (element.dtmf && ! element.voice) {\n\t\t\t\t\t\tprint('\\n\\t\\t<property name=\"inputmodes\" value=\"dtmf\" />');\n\t\t\t\t\t} else if (! element.dtmf && element.voice) {\n\t\t\t\t\t\tprint('\\n\\t\\t<property name=\"inputmodes\" value=\"voice\" />');\n\t\t\t\t\t}\n\t\t\t\t\trule = element.name + 'Rule';\n\n          if (element.name && element.dtmf && element.dtmfGrammar) {\n            dtmf = element.dtmfGrammar.split(/\\s*,\\s*/);\n            if (dtmf.length) {\n              print('\\n\\t\\t<grammar type=\"application/grammar-xml\" xml:lang=\"en-US\" version=\"1.0\" root=\"' + rule + '\" mode=\"dtmf\">');\n              print('\\n\\t\\t\\t<rule id=\"' + rule + '\" scope=\"public\">');\n              print('\\n\\t\\t\\t<one-of>');\n              for (var di = 0; di < dtmf.length; di++) {\n                if (dtmf[di]) {\n                \tprint('\\n\\t\\t\\t\\t<item>' + dtmf[di] + '</item>');\n                }  \n              }  \n              print('\\n\\t\\t\\t</one-of>');\n              print('\\n\\t\\t\\t</rule>');\n              print('\\n\\t\\t</grammar>');\n            }\n          }\n          if (element.name && element.voice && element.voiceGrammar) {\n            voice = element.voiceGrammar.split(/\\s*,\\s*/);\n            if (voice.length) {\n              print('\\n\\t\\t<grammar type=\"application/grammar-xml\" xml:lang=\"en-US\" version=\"1.0\" root=\"' + rule + '\" mode=\"voice\">');\n              print('\\n\\t\\t\\t<rule id=\"' + rule + '\" scope=\"public\">');\n              print('\\n\\t\\t\\t<one-of>');\n              for (var di = 0; di < voice.length; di++) {\n                if (voice[di]) {\n                \tprint('\\n\\t\\t\\t\\t<item>' + voice[di] + '</item>');\n                }  \n              }  \n              print('\\n\\t\\t\\t</one-of>');\n              print('\\n\\t\\t\\t</rule>');\n              print('\\n\\t\\t</grammar>');\n            }\n          }\n          \n\t\t\t\t\tif (element.txt) {\n\t\t\t\t\t\tprint(speak(element, element.txt, flow.raw.audio));\n\t\t\t\t\t}\n\n\t\t\t\t\tprint('\\n\\t\\t<noinput>');\n          if (element.noInput) {\n\t\t\t\t\t\tprint(speak(element, element.noInput, flow.raw.audio));\n          }\n          print('<reprompt />');\n\t\t\t\t\tprint('\\n\\t\\t</noinput>');\n\t\t\t\t\t\n\t\t\t\t\tprint('\\n\\t\\t<nomatch>');\n          if (element.noMatch) {\n\t\t\t\t\t\tprint(speak(element, element.noMatch, flow.raw.audio));\n          }\n          print('<reprompt />');\n\t\t\t\t\tprint('\\n\\t\\t</nomatch>');\n\t\t\t\t\t\n          // exit if reprompt times and goodBye message is set\n          if (element.goodBye && element.reprompt) {\n           \tprint('\\n\\t\\t<noinput count=\"'+ element.reprompt +'\">');\n            print(speak(element, element.goodBye, flow.raw.audio));\n            print('\\n\\t\\t<exit />');\n            print('\\n\\t\\t</noinput>');\n\t\t\t\t\t\tprint('\\n\\t\\t<nomatch count=\"'+ element.reprompt +'\">');\n            print(speak(element, element.goodBye, flow.raw.audio));\n            print('\\n\\t\\t<exit />');\n            print('\\n\\t\\t</nomatch>');\n          }\n\t\t\t\t\tprint('\\n\\t</field>');\n\t\t\t\t}\n\t\t\t})\n\t\t\tif (fields.length) {\n\t\t\t\tprint('\\n\\t<filled mode=\"all\" namelist=\"' + fields.join(' ') + '\">');\n\t\t\t\tprint('\\n\\t\\t<submit next=\"${internal.nextURL}?_dt=$DateTime.now().getMillis()\" />');\n\t\t\t\tprint('\\n\\t</filled>');\n\t\t\t}\n\t\t\tprint('\\n</form>');\n\t\t}\n\t});\n\n%>\n</vxml>\n"
    },
    {
      "name": "ccxml",
      "mimeType": "application/ccxml+xml",
      "template": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ccxml version=\"1.0\" xmlns:voxeo=\"http://community.voxeo.com/xmlns/ccxml\">\n\n\t#set($d = \"$\")\n  <var name=\"callTimeout\" expr=\"'60s'\" />\n  <var name=\"state\" expr=\"'init'\"/>\n\n  <!-- OUTGOING, INCOMING -->\n  <var name=\"direction\" expr=\"'${internal.callDirection}'\" />\n  <var name=\"statusURL\" expr=\"'${internal.baseURL}/callflows/status/${internal.callId}'\" />\n  <var name=\"connectionId\" expr=\"'outboundID'\" />\n  <var name=\"callId\" expr=\"'${internal.callId}'\" />\n  <var name=\"jumpTo\" expr=\"'${internal.jumpTo}'\" />\n  <var name=\"direction\" expr=\"'${internal.callDirection}'\" />\n\n  <log expr=\"'startupmode = ' + session.startupmode\"/>\n \n  <eventprocessor>\n\n    <!-- CCXML Loaded -->\n    <transition event=\"ccxml.loaded\">\n      <log expr=\"'ccxml loaded'\" />\n      <if cond=\"session.startupmode === 'external'\">\n        <!-- tel:xxxx, sip:xxx@h:p sip:user@127.0.0.1:5070  -->\n        <createcall dest=\"'tel:+' + '${phone}'\" callerid=\"'${phone}'\" connectionid=\"connectionId\" timeout=\"callTimeout\"/>\n      </if>\n    </transition>\n   \n    <!-- Process the incoming call --> \n    <transition event=\"connection.alerting\">\n      <log expr=\"'connection.alerting'\" />\n      <accept/>     \n    </transition>\n      \n    <transition event=\"connection.failed\">\n      <var name=\"eventReason\" expr=\"event${d}.reason\" />\n\t\t\t<var name=\"status\" expr=\"eventReason === 'timeout' ? 'NO_ANSWER' : eventReason === 'busy' ? 'BUSY' : 'FAILED'\" />\n      <var name=\"reason\" expr=\"event${d}.reason\" />\n\t\t\t<var name=\"timestamp\" expr=\"(+new Date)\"/>\n\n      <log expr=\"'status=' + status + '; reason = ' + reason\" /> \n\t\t\t<send target=\"statusURL + ''\" targettype=\"'basichttp'\" name=\"'http.get'\" namelist=\"status reason timestamp\"/>      \n\n    </transition>\n\n    <!-- Call has been answered.--> \n    <transition event=\"connection.connected\">\n      <log expr=\"'connection.connected -> ${internal.callId}'\" />\n\t\t\t\t<dialogstart src=\"'${internal.baseURL}/callflows/in/voxeo/flows/MainFlow.vxml'\" namelist=\"session.id application.callerId callId  #if($internal.callDirection == 'OUTGOING') jumpTo #end\" />\n      <var name=\"status\" expr=\"'IN_PROGRESS'\" />\n      <var name=\"reason\" expr=\"'connected'\" />\n\t\t\t<var name=\"timestamp\" expr=\"(+new Date)\"/>\n      <var name=\"externalId\" expr=\"session.id\" />\n      <var name=\"externalType\" expr=\"'voxeoSessionId'\" />\n      <send data=\"'callMaxTimeReached'\" target=\"session.id\" delay=\"'600s'\" />\n      <log expr=\"'status=' + status + '; reason = ' + reason\" /> \n\t\t\t<send target=\"statusURL + ''\" targettype=\"'basichttp'\" name=\"'http.get'\" namelist=\"status reason externalId externalType timestamp\"/>      \n    </transition>\n    \n    <transition event=\"callMaxTimeReached\">\n      <log expr=\"'-- Max Call Time Reached / Disconnecting Call --'\" />\n      <var name=\"status\" expr=\"'COMPLETED'\" />\n      <var name=\"reason\" expr=\"'Max time reached'\" />\n\t\t\t<var name=\"timestamp\" expr=\"(+new Date)\"/>\n      <log expr=\"'status=' + status + '; reason = ' + reason\" />   \n   \t\t<send target=\"statusURL + ''\" targettype=\"'basichttp'\" name=\"'http.get'\" namelist=\"status reason timestamp\"/>  \n      <disconnect/>  \n\t\t</transition>  \n\n    <!-- Caller hung up.  -->\n    <transition event=\"connection.disconnected\">\n      <log expr=\"'connection.disconnected -> ${internal.callId}'\" />\n      \n      <var name=\"status\" expr=\"'COMPLETED'\" />\n      <var name=\"reason\" expr=\"event${d}.trigger\" />\n      <var name=\"timestamp\" expr=\"(+new Date)\"/>\n      <log expr=\"'status=' + status + '; reason = ' + reason\" /> \n\n\t\t\t<send target=\"statusURL + ''\" targettype=\"'basichttp'\" name=\"'http.get'\" namelist=\"status reason timestamp\"/>\n    </transition>\n    \n    <transition event=\"dialog.started\">\n      <log expr=\"'dialog.started -> ${internal.callId}'\" />\n\t\t\t<var name=\"status\" expr=\"'IN_PROGRESS'\" />\n      <var name=\"reason\" expr=\"'dialog start'\" />\n      <var name=\"timestamp\" expr=\"(+new Date)\"/>\n      <log expr=\"'status=' + status + '; reason = ' + reason\" /> \n\t\t\t<send target=\"statusURL + ''\" targettype=\"'basichttp'\" name=\"'http.get'\" namelist=\"status reason timestamp\"/>\n\n    </transition>\n     \n    <!-- Dialog exit -->\n    <transition event=\"dialog.exit\">\n      <log expr=\"'dialog.exit -> ${internal.callId}'\" />\n      <disconnect />\n    </transition>\n\n    <!-- ERROR!! -->\n    <transition event=\"error.*\" >\n      <log expr=\"'Error[CFL]: (' + event${d}.reason + ')'\"/>\n      <exit/>\n    </transition>\n\n  </eventprocessor>\n\n</ccxml>\n"
    }
  ]
}

